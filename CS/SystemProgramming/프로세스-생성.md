# 프로세스 생성

## # 기본 구조

- CODE(TEXT), DATA, BSS, HEAP, STACK
- BSS는 초기 값이 없는 변수가 들어간다.

## # 생성 과정

- CODE, DATA, BSS, HEAP, STACK 공간 생성
- 프로세스 이미지를 해당 공간에 업로드하고, 실행

## # 프로세스 계층

- 다른 프로세스는 또 다른 프로세스로부터 생성 (부모, 자식 프로세스)

## # fork() 시스템콜

- **fork() - 복사** : 새로운 프로세스 공간을 별도로 만들어 fork() 시스템콜을 호출한 프로세스 공간을 모두 복사한다. 즉, 별도의 프로세스 공간을 만들고, 부모 프로세스 공간의 데이터를 그대로 복사한다.

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main() {
  pid_t pid;
  printf("fork() 호출\n");
  pid = fork();

  if (pid == 0)
    printf("나는야 자식 프로세스(PID=%d)\n", pid);
  else if (pid > 0)
    printf("나는야 부모 프로세스(PID=%d)\n", pid);
  else
    printf("fork() 실패\n");
  return 0;
}
```

- 자식 프로세스는 pid가 0으로 리턴, 부모 프로세스는 실제 pid 리턴
- 두 프로세스 변수 및 PC는 동일하다.
- 새로운 프로세스 공간을 별도로 만들고, fork() 시스템콜을 호출한 프로세스 공간을 모두 복사하고 fork() 시스템콜 이후 코드부터 실행

## # exec() 시스템콜

- **exec() - 덮어씌우기** : exec() 시스템콜을 호출한 현재 프로세스 공간의 CODE, DATA, BSS 영역을 새로운 프로세스 이미지로 덮어 씌운다. 즉, 별도의 프로세스 공간을 만들지 않는다.
- **perror()**: 해당 함수를 호출하는 것은 새로운 프로세스 이미지로 덮어씌우는 작업이 실행되지 못했다는 의미이다. 즉, execl() 시스템콜 실행 실패
- **execlp()** : 파일 이름만 넘겨주면 프로세스 환경변수에서 파일명을 검색한다.
- **execle()** : 환경변수를 별도로 정의해서 넘겨준다.
- **execl()** : 파일명을 전체 경로를 포함해서 넘겨준다.
- ***execvp(), execv(), execve()** : argv를 생성하고 넘겨줘야 한다.*

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
	printf("execute ls\n");
	execl("/bin/ls", "ls", "-l", NULL); //ls -l 실행
	perror("execl is failed\n");
	exit(1);
}
```

## # wait() 시스템콜

- wait() : fork() 함수 호출시, 자식 프로세스가 종료할 때까지 부모 프로세스가 기다린다.
- 자식, 부모 프로세스의 동기화하기 위해 제공한다.
- 부모 프로세스가 자식 프로세스보다 먼저 죽는 경우를 막기 위해 사용 (고아 프로세스)

## # fork(), execl(), wait() 시스템콜

- execl()만 사용하면 부모 프로세스가 사라진다.
- 이를 유지하기 위하여 fork()로 새로운 프로세스 공간 복사 후, execl()을 사용하는 것을 권장하고 있다.
- wait() 함수를 사용해서 부모 프로세스가 자식 프로세스가 끝날때 까지 기다릴 수 있다.

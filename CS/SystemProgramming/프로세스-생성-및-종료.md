# 프로세스 생성 및 종료

## # 기본 구조

- CODE(TEXT), DATA, BSS, HEAP, STACK
- BSS는 초기 값이 없는 변수가 들어간다.
- 프로세스 당 4GB 가상 메모리 할당

## # 생성 과정

- CODE, DATA, BSS, HEAP, STACK 공간 생성
- 프로세스 이미지를 해당 공간에 업로드하고, 실행

## # 프로세스 계층

- 다른 프로세스는 또 다른 프로세스로부터 생성 (부모, 자식 프로세스)

## # fork() 시스템콜

- **fork() - 복사** : 새로운 프로세스 공간을 별도로 만들어 fork() 시스템콜을 호출한 프로세스 공간을 모두 복사한다. 즉, 별도의 프로세스 공간을 만들고, 부모 프로세스 공간의 데이터를 그대로 복사한다.

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main() {
  pid_t pid;
  printf("fork() 호출\n");
  pid = fork();

  if (pid == 0)
    printf("나는야 자식 프로세스(PID=%d)\n", pid);
  else if (pid > 0)
    printf("나는야 부모 프로세스(PID=%d)\n", pid);
  else
    printf("fork() 실패\n");
  return 0;
}
```

- 자식 프로세스는 pid가 0으로 리턴, 부모 프로세스는 실제 pid 리턴
- 두 프로세스 변수 및 PC는 동일하다.
- 새로운 프로세스 공간을 별도로 만들고, fork() 시스템콜을 호출한 프로세스 공간을 모두 복사하고 fork() 시스템콜 이후 코드부터 실행

## # exec() 시스템콜

- **exec() - 덮어씌우기** : exec() 시스템콜을 호출한 현재 프로세스 공간의 CODE, DATA, BSS 영역을 새로운 프로세스 이미지로 덮어 씌운다. 즉, 별도의 프로세스 공간을 만들지 않는다.
- **perror()**: 해당 함수를 호출하는 것은 새로운 프로세스 이미지로 덮어씌우는 작업이 실행되지 못했다는 의미이다. 즉, execl() 시스템콜 실행 실패
- **execlp()** : 파일 이름만 넘겨주면 프로세스 환경변수에서 파일명을 검색한다.
- **execle()** : 환경변수를 별도로 정의해서 넘겨준다.
- **execl()** : 파일명을 전체 경로를 포함해서 넘겨준다.
- *execvp(), execv(), execve() : argv를 생성하고 넘겨줘야 한다.*

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
	printf("execute ls\n");
	execl("/bin/ls", "ls", "-l", NULL); //ls -l 실행
	perror("execl is failed\n");
	exit(1);
}
```

## # wait() 시스템콜

- wait() : fork() 함수 호출시, 자식 프로세스가 종료할 때까지 부모 프로세스가 기다린다.
- 자식, 부모 프로세스의 동기화하기 위해 제공한다.
- 부모 프로세스가 자식 프로세스보다 먼저 죽는 경우를 막기 위해 사용 (고아 프로세스)

## # fork(), execl(), wait() 시스템콜

- execl()만 사용하면 부모 프로세스가 사라진다.
- 이를 유지하기 위하여 fork()로 새로운 프로세스 공간 복사 후, execl()을 사용하는 것을 권장하고 있다.
- wait() 함수를 사용해서 부모 프로세스가 자식 프로세스가 끝날때 까지 기다릴 수 있다.

## # copy-on-write

### fork() 문제점

fork()는 새로운 프로세스 공간 생성 후, 기존 프로세스 공간을 복사하는데 4GB를 복사한다면, 프로세스 생성 시간이 매우 오래 걸린다. 해당 문제점을 해결하기 위해 copy-on-write가 등장했다.

### 동작

- 자식 프로세스 생성시, 부모 프로세스 페이지를 우선으로 사용한다.
- 부모 혹은 자식 프로세스가 해당 페이지를 읽기가 아닌 쓰기를 할 때 이 때 페이지를 복사하고 분리한다.

### 장점

- 프로세스 생성 시간을 줄일 수 있다.
- 새로 생성된 프로세스에 새롭게 할당되어야 하는 페이지 수도 최소화 할 수 있다.

# 프로세스 종료

## # exit() 시스템콜

프로세스를 종료하는 역할을 수행한다.

### C언어 main 함수의 return 0;과 exit(0);의 차이점

- **exit() 함수** : 즉시 프로세스를 종료한다. 해당 함수 이후 코드를 실행하지 않는다.
- **return 0;** : 단지 main()이라는 함수를 종료한다. c언어에서 기본으로 포함된 _start() 함수를 호출하게 되고, 내부적으로 결국 exit()를 호출하고 있다.
- 사실상 이 둘의 큰 차이는 없다.

### 주요 동작

- atexit()에 등록된 함수 실행한다.
- 열려 있는 모든 입출력 스트림 버퍼를 삭제한다.
(대표적인 입출력 스트림인 stdin, stdout, stderr 파일에 있는 데이터를 삭제한다)
- 프로세스가 오픈한 파일을 모두 닫는다.
- tmpfile() 함수를 통해 생성한 임시 파일을 삭제한다.
